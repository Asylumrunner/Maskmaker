# Maskmaker
A Node.js API for generating non-player characters for tabletop role-playing games

## Overview
I run a number of tabletop RPGs for a variety of groups, and one of the hardest parts for me is coming up with distinct personalities for non-player characters (NPCs) on the spot. So, I decided to write myself an application that could automatically generate NPCs, at least in the broad strokes, on my behalf.

This API has two core pieces of functionality. The first is the ability to generate characters, taking in a number representing the number of characters to generate, and outputting a list of that many JSON objects, each containing a name, a set of personality traits, and a list of attributes (tabletop RPGs usually use statistical attributes to represent things like a character's intelligence or strength) described in relative terms. Optionally, a user may supply a region from which to choose names, a gender for the characters, and a list of custom attribute titles to use (if no attributes are given, the API defaults to the classic Dungeons and Dragons attributes).

A separate endpoint also allows users to submit a list of their own pregenerated names, in which case the API will randomly assign names from that list to the generated characters instead of producing names of its own. This ties in to the API's second piece of functionality: name generation.

By posting to a /markov endpoint with a list of example names, the API can also produce a Markov Chain trained on that test data set. This Markov Chain is then returned to the user, who can then provide it as an argument in the body to another endpoint, which takes a Markov Chain (it doesn't need to be one generated by the API, as long as it fits the format) and produces a number of names with it, of variable names within a minimum and maximum defined in the body.

There are two primary consumers I plan to build for this application. The first is a Discord bot which will consume this API and use it to generate NPCs on the fly for a GM of an online tabletop game. The second application is a consumer which will take the output of this API and convert it into CSV tables which can be used with an application called [CardMaker](https://github.com/nhmkdev/cardmaker), which can take csvs and turn them into printable card sheets. This is useful for physical play sessions, in which I'd like to have a "deck" of NPCs ready to go, but would prefer to not be shackled to electronics while I play.

## Tech Stack
The project that would eventually become Maskmaker was originally written in Python 3. However, as a learning exercise, I decided to port it to Node.js 10, allowing me to leverage the extremely powerful Express library to create the API with relative ease. This project also leverages Claudia, an automated pipeline wrapped around aws-serverless-express which allows me to deploy Maskmaker to AWS Lambda and publish the API through API Gateway.

## Character Generation
Characters generated by this application have three primary components. The first is a name, randomly selected from a list generated by hitting the random name API provided by [http://uinames.com](http://uinames.com). These names are originally given in their native alphabet, so Node's unidecode package is used to convert them to printable English, a method that still produces some occasional bugs but is generally successful.

Characters also have a set of three personality traits randomly assigned to them. These are pulled from a list of character traits randomly, such that no trait is shared between characters.

The last aspect of a character are approximate statistical attributes. Most RPGs use some sort of numerical system to represent characters' attributes, but using any of those systems in this application would limit its usefulness. Instead, the user may enter the set of attributes they want to use, or use the default D&D stats. Then, the application will go through every attribute for every character, and decide if the character is, in that stat, pathetically inept, lower than average, average, better than average, or exceptional. The numbers are weighted such that average score are more likely than non-average scores.

## Endpoint Documentation

### Valid Markov Chains

## Additional Scope
While programmatic handling of the Markov Chain objects is simple, manually using the Markov Chain endpoints is kind of a pain. As both a potential for further learning and to increase usability, I think it would be useful to be able to store those chains in a database. Then, when I want to use a Markov Chain to generate names, I can simply provide a database key as an argument to the API and have it withdraw it manually. This has a few key advantages:
* As previously mentioned, it makes building payloads for the Markov name generation endpoint easier. You just need to provide a key and some database credentials instead of a 27 x 26 2D array
* I only need to validate the chain once, when I insert it into the database. I can assume anything I pull out has already been validated
* I can use the same chain over and over again over a long period of time, conducive to RPG play (a single RPG campaign can take years)

To implement this, I'd probably want to avoid any significant performance hits to the API that I can. So, when I generate a Markov Chain, I'd probably want to post it somewhere (probably an S3 bucket?) for another Lambda function to pick up and process without delaying the API execution time any further.

Further optimization could be done by caching Markov Chains retrieved from said database, but until this API is used by more people than, well, me, that degree of optimization feels like overkill. Maybe as a learning exercise.

## To-Do List
* Store Markov Chains in a database because dear god those things are hideously ugly to manipulate
* Implement database wiper
* Implement tests